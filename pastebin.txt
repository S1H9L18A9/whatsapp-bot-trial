#!/usr/bin/env python3
import fcntl
import time
import random
import os
from datetime import datetime

def safe_remove_lines(filename, lines_to_remove, max_retries=10):
    """Safely remove specific lines from file with file locking"""
    if not lines_to_remove:
        return True
        
    for attempt in range(max_retries):
        try:
            with open(filename, 'r+') as f:
                fcntl.flock(f.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
                
                # Read all lines
                f.seek(0)
                all_lines = f.readlines()
                
                # Remove the specified lines
                lines_to_remove_set = set(line.strip() for line in lines_to_remove)
                remaining_lines = []
                removed_count = 0
                
                for line in all_lines:
                    if line.strip() in lines_to_remove_set:
                        removed_count += 1
                        print(f"[REMOVER] Removing: {line.strip()}")
                    else:
                        remaining_lines.append(line)
                
                # Write back the remaining lines
                f.seek(0)
                f.writelines(remaining_lines)
                f.truncate()  # Remove any leftover content
                f.flush()
                
                print(f"[REMOVER] Successfully removed {removed_count} lines")
                return True
                
        except (IOError, OSError) as e:
            print(f"[REMOVER] Attempt {attempt + 1}: File locked, retrying...")
            time.sleep(0.1 + attempt * 0.05)
            continue
        except FileNotFoundError:
            print(f"[REMOVER] File {filename} doesn't exist yet, waiting...")
            time.sleep(1)
            continue
    
    print(f"[REMOVER] FAILED to remove lines after {max_retries} attempts")
    return False

def safe_peek_lines(filename, count=3, max_retries=5):
    """Safely read first N lines from file"""
    for attempt in range(max_retries):
        try:
            with open(filename, 'r') as f:
                fcntl.flock(f.fileno(), fcntl.LOCK_SH | fcntl.LOCK_NB)  # Shared lock for reading
                lines = []
                for i, line in enumerate(f):
                    if i >= count:
                        break
                    lines.append(line.strip())
                return lines
                
        except (IOError, OSError) as e:
            print(f"[REMOVER] Peek attempt {attempt + 1}: File locked")
            time.sleep(0.1)
            continue
        except FileNotFoundError:
            return []
    
    return []

def main():
    filename = "shared_queue.txt"
    
    print("[REMOVER] Starting - will remove lines every 3-7 seconds")
    
    while True:
        # Check if there are lines to process
        available_lines = safe_peek_lines(filename, count=5)
        
        if not available_lines:
            print("[REMOVER] No lines available, waiting...")
            time.sleep(2)
            continue
        
        # Take 1-3 lines to "process"
        lines_to_take = min(random.randint(1, 3), len(available_lines))
        lines_to_process = available_lines[:lines_to_take]
        
        print(f"[REMOVER] Processing {lines_to_take} folders: {lines_to_process}")
        
        # Simulate processing time (upload time)
        processing_time = random.uniform(2.0, 4.0)
        print(f"[REMOVER] Simulating upload for {processing_time:.1f}s...")
        time.sleep(processing_time)
        
        # Remove the processed lines
        safe_remove_lines(filename, lines_to_process)
        
        # Wait before next batch
        delay = random.uniform(3.0, 7.0)
        print(f"[REMOVER] Waiting {delay:.1f}s before next batch...")
        time.sleep(delay)

if __name__ == "__main__":
    main()
